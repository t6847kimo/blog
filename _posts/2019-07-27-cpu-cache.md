---
title: CPU Cache對效能的影響
layout: post
tags:
- Computer Architecture
- Performance
published: false
comments: true
---

最近跟學長討論到一個蠻有名的面試題目「該如何用程式算出 L1 / L2 Cache size？」<br>
雖然蠻有名但是沒有仔細研究過，今天就來好好研究一下！

這篇算是筆記我Google到的一些有價值的東西，加上一些我自己的實驗數據跟大家分享。

先將參考的網站列出來，上面都寫的非常詳細且深入，如果覺得我寫的太淺可以再進去參考~
### Refernce
[現代處理器設計: Cache 原理和實際影響](https://hackmd.io/@jserv/HkW3Dr1Rb?type=view)

[Gallery of Processor Cache Effects](http://igoro.com/archive/gallery-of-processor-cache-effects/)

[What Every Programmer Should Know About Memory](https://akkadia.org/drepper/cpumemory.pdf)

## 什麼是Cache

假設L2 Cache Size = **L2** Bytes, L1 Cache Size = **L1** Bytes, <br>
則我們當我們存取某一個不在Cache的位置(e.g. 0xABCD)時，CPU會將 (0xABCD, 0xABCD + L2)的Data搬往 L2 Cache<br>
接著將(0xABCD, 0xABCD + L1)的Data搬往 L1 Cache<br>
當然實際上沒有那麼簡單，因為Cache中一定有其他資料，所以必須考慮使用的頻率等因素。

## Type of Cache Miss

> Compulsory misses（強迫性失誤）：也稱為 cold start misses，第一次存取未曾在 cache 內的 block 而發生的 cache miss ，這種 miss 是不可避免的。
> 
> Capacity misses（空間性失誤）：因為在程式執行期間， cache 無法包含所有需要的 block 而產生的 cache miss。發生在一個 block 被取代後，稍後卻又需要用到。
> 
> Conflict misses（衝突性失誤）：發生在 set-associative 或 direct-mapped caches ，當多個 blocks 競爭相同的 set。通常也稱作 collision misses。
> 

### Cache Line Miss
### L1 / L2 Cache Miss

## Reason of Cache Collision



## 程式設計師一定要知道的Latency
標題很屁XD，但是其實是有道理的，如果不是只想寫出一些能「跑」的程式，而是想要寫出能「飛」的程式，就不能不了解電腦的運作原理，這篇也只能講到冰山一角而已，待之後讀更多書了再來分享。

下圖說明，CPU的速度每年可以成長60%，相較之下RAM只能成長7%，所以其實CPU做運算的速度比從RAM讀/寫資料快的多。

![Memory Access vs CPU Speed](https://www.researchgate.net/profile/Christine_Eisenbeis/publication/254014003/figure/fig1/AS:393211676774402@1470760377534/Memory-Access-vs-CPU-Speed.png)

(圖片來源: [https://www.researchgate.net/figure/Memory-Access-vs-CPU-Speed_fig1_254014003](https://www.researchgate.net/figure/Memory-Access-vs-CPU-Speed_fig1_254014003))

而實際上的Latency可以參考下表，可以整理出以下對比 (越小越快)

* CPU : L1 Cache  = 1 : 1
* L1 Cache : L2 Cache  = 1 : 14
* CPU : RAM  = 1 : 100
* RAM : Disk  = 1 : 80000

[*Approximate timing for various operations on a typical PC*](http://norvig.com/21-days.html#answers)

| Action                              | Delay                                  |
|-------------------------------------|----------------------------------------|
| execute typical instruction         | 1/1,000,000,000 sec = 1 nanosec        |
| fetch from L1 cache memory          | 0.5 nanosec                            |
| branch misprediction                | 5 nanosec                              |
| fetch from L2 cache memory          | 7 nanosec                              |
| Mutex lock/unlock                   | 25 nanosec                             |
| fetch from main memory              | 100 nanosec                            |
| send 2K bytes over 1Gbps network    | 20,000 nanosec                         |
| read 1MB sequentially from memory   | 250,000 nanosec                        |
| fetch from new disk location (seek) | 8,000,000 nanosec                      |
| read 1MB sequentially from disk     | 20,000,000 nanosec                     |
| send packet US to Europe and back   | 150 milliseconds = 150,000,000 nanosec |

[Latency Numbers Every Programmer Should Know](https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html) 這個網站將上表以圖呈現，並有逐年比較的數字，可以考古一下電腦速度是怎麼演化的，有興趣的可以進去玩一下。

## Q1: 如何計算 Cache Line Size
```cpp
void access_array(char* arr, int steps)
{
    const int loop_cnt = 1024 * 1024 * 32; // arbitary loop count
    int idx = 0;
    for (int i = 0; i < loop_cnt; i++)
    {
        arr[idx] += 10;
        idx = (idx + steps) & (ARRAY_SIZE - 1); // if use %, the latency will be too high to see the gap
    }
}
```

實驗結果

![Cache Line Size](https://github.com/t6847kimo/blog/blob/master/assets/img/cache_line_size_step_vs_time.PNG?raw=true)

可以發現執行時間在 Step = **64, 1K, 4K** 時明顯的上升了，分析如下
* Step = 64，此時每個iteration都會導致一次 **Cache Line Miss**

#### Step = 1,
* 每 **64** 次會有一次 `cache line miss` -> 共 **32 M / 64** 次
* L1每 **32K** 次會有一次 `L1 cache miss` -> 共 **32 M / 32K** 次
* L2 Cache比Array Size大，所以不會Miss

#### Step = 2,
* 每 **32** 次會有一次 `cache line miss` -> 共 **32 M / 32** 次
* L1每 **16K** 次會有一次 `L1 cache miss` -> 共 **32 M / 16K** 次

#### Step = 64,
* 每 **1** 次會有一次 `cache line miss` -> 共 **32 M** 次
* L1每 **512** 次會有一次 `L1 cache miss` -> 共 **32 M / 512** 次



* 每 **1** 次會有一次 `cache line miss` -> 共 **32 M** 次

#### Step = 512,
一共存取 512個位置，每512 Bytes分一個Set -> 一共用 64個Set，剛好可利用到Set用滿




#### Step = 1K,
* 每 **1** 次會有一次 `cache line miss` -> 共 **32 M** 次
* L1每 **32** 次會有一次 `L1 cache miss` -> 共 **32 M / 32** 次
* 每 **1**次會有一次 `L1 conflict miss` -> 共 **32M** 次
* 
#### Step = 4K,
* 每 **1** 次會有一次 `cache line miss` -> 共 **32 M** 次
* L1每 **8** 次會有一次 `L1 cache miss` -> 共 **32 M / 8** 次
* 每 **1**次會有一次 `L1 conflict miss` -> 共 **32M** 次


* Step = 1K，此時每個iteration都會導致一個 **Cache Line Miss**
* Step = 4K，此時每個iteration都會導致一個 **Cache Line Miss**

8-Way Cache -> 每個Block (64 Bytes)有8個選擇 (512 Bytes)，一共有 32K / 512 = 64個Set
每64個Set會撞一次 -> 每 64 * 512 = 4K Bytes撞一次

`getconf -a | grep CACHE`

```
LEVEL1_ICACHE_SIZE                 32768
LEVEL1_ICACHE_ASSOC                8
LEVEL1_ICACHE_LINESIZE             64
LEVEL1_DCACHE_SIZE                 32768
LEVEL1_DCACHE_ASSOC                8
LEVEL1_DCACHE_LINESIZE             64
LEVEL2_CACHE_SIZE                  262144
LEVEL2_CACHE_ASSOC                 8
LEVEL2_CACHE_LINESIZE              64
LEVEL3_CACHE_SIZE                  15728640
LEVEL3_CACHE_ASSOC                 20
LEVEL3_CACHE_LINESIZE              64
LEVEL4_CACHE_SIZE                  0
LEVEL4_CACHE_ASSOC                 0
LEVEL4_CACHE_LINESIZE              0
```


## Q2: 如何計算 L1 Cache & L2 Cache Size